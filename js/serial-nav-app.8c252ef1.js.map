{"version":3,"sources":["webpack:///./src/plugins/serial/base-serial.js","webpack:///./src/plugins/serial/navserial.js"],"names":["BaseSerial","requestRequired","mute","baud","Number","window","localStorage","currentBaudRate","lastBaud","encoding","devices","currentDevice","connected","implementation","Vue","$serial","this","prototype","Promise","all","map","device","isDevice","value","isDevices","filter","i","disconnect","console","error","connect","setBaud","val","sig","dtr","rts","dataTerminalReady","requestToSend","signals","message","buff","name","push","find","d","EventEmitter","navigator","serial","asyncTimeout","ms","resolve","setTimeout","log","NavSerial","JSON","parse","portNames","_currentDevice","_rl","_reader","handlesSelect","id","readable","getReader","read","done","releaseLock","emit","Buffer","from","toString","_readLoop","cancel","stopReadLoop","requestPort","classCode","setCurrentDevice","_getDevice","set","writer","writable","getWriter","write","writeBuff","open","baudrate","baudRate","Math","random","close","stringify","Error","sigs","_transSignal","setSignals"],"mappings":"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","file":"js/serial-nav-app.8c252ef1.js","sourcesContent":["/* eslint-disable no-unused-vars */\n/* eslint-disable class-methods-use-this */\nimport EventEmitter from 'events';\n\n/*\nInterface should emit the following:\nthis.emit('data', buffer)\nthis.emit('message', string) // should be a string version of buffer\n// message should not be emitted whilst this.mute === true\nthis.emit('connected', value)\nthis.emit('disconnected', value)\nthis.emit('deviceNamePrompt', value) // prompts the user to input a readable device name\n*/\nclass BaseSerial extends EventEmitter {\n  constructor() {\n    super();\n    this.requestRequired = false;\n    this.mute = false;\n    this.baud = Number(window.localStorage.currentBaudRate) || 115200;\n    this.lastBaud = 115200;\n    this.encoding = 'ascii';\n    this.devices = [];\n    this.currentDevice = null;\n    this.connected = false;\n    this.implementation = 'basic';\n  }\n\n  install(Vue) {\n    // eslint-disable-next-line no-param-reassign\n    Vue.$serial = this;\n    // eslint-disable-next-line no-param-reassign\n    Vue.prototype.$serial = this;\n  }\n\n  async requestDevice() { return {}; }\n\n  async listDevices() {\n    const isDevices = await Promise.all(this.devices.map((device) => this.isDevice(device.value)));\n    return this.devices.filter((device, i) => isDevices[i]);\n  }\n\n  async isDevice(value) { return true; }\n\n  async setCurrentDevice(value) { this.currentDevice = value; }\n\n  async setBaud(baud) {\n    try {\n      await this.disconnect();\n      // eslint-disable-next-line no-console\n    } catch (err) { console.error(err); }\n    // eslint-disable-next-line no-console\n    // console.log('disconnected');\n    this.lastBaud = this.baud;\n    this.baud = baud;\n    await this.connect();\n    // eslint-disable-next-line no-console\n    // console.log('connected');\n    window.localStorage.currentBaudRate = baud;\n    return baud;\n  }\n\n  async resetBaud() {\n    this.setBaud(this.lastBaud);\n  }\n\n  async setMute(val) { this.mute = val; }\n\n  _transSignal(sig) {\n    if (sig === 'on' || sig === true) {\n      return {\n        dtr: true,\n        rts: true,\n        dataTerminalReady: true,\n        requestToSend: true,\n      };\n    }\n    if (sig === 'off' || sig === false) {\n      return {\n        dtr: false,\n        rts: false,\n        dataTerminalReady: false,\n        requestToSend: false,\n      };\n    }\n    return sig;\n  }\n\n  async setSignals(signals) { return signals; }\n\n  async write(message) { return message; }\n\n  async writeBuff(buff) { return buff; }\n\n  async connect() { this.connected = true; }\n\n  async disconnect() { this.connected = false; }\n\n  async setDeviceName(value, name) {\n    if (await this.isDevice(value)) this.devices.push({ value, name });\n  }\n\n  async getDeviceName(value) {\n    return (this.devices.find((d) => d.value === value) || { name: '' }).name;\n  }\n}\n\nexport default BaseSerial;\n","import Vue from 'vue';\n// import { v4 as uuid4 } from 'uuid';\nimport BaseSerial from './base-serial';\n\nconst { serial } = navigator;\nconst asyncTimeout = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\n\n// eslint-disable-next-line no-console\nconsole.log('using navserial');\nclass NavSerial extends BaseSerial {\n  constructor() {\n    super();\n    this.requestRequired = true;\n    this.devices = JSON.parse(localStorage.portNames || '[]');\n    this._currentDevice = null;\n    this._rl = false;\n    this._reader = null;\n    this.implementation = 'navserial';\n    this.handlesSelect = true;\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  async _getDevice(value) {\n    // const devices = await serial.getPorts();\n    // console.log(devices);\n    // return devices.find((d) => d.id === value) || null;\n    return value;\n  }\n\n  async _readLoop(id) {\n    if (!this._rl || id !== this._rl) return;\n    if (!this._currentDevice || !this._currentDevice.readable) {\n      this._rl = false;\n      return;\n    }\n    try {\n      this._reader = this._currentDevice.readable.getReader();\n      // eslint-disable-next-line no-constant-condition\n      while (id === this._rl) {\n        // eslint-disable-next-line no-await-in-loop\n        const { value, done } = await this._reader.read();\n        if (done) {\n          this._reader.releaseLock();\n          break;\n        }\n        // eslint-disable-next-line no-console\n        // console.log('read', Buffer.from(value).toString('hex'));\n        this.emit('data', Buffer.from(value));\n        if (!this.mute) this.emit('message', Buffer.from(value).toString(this.encoding));\n      }\n    } catch (e) {\n      this.emit('message', `<ERROR: ${e.message}>`);\n    }\n    if (this._reader) this._reader.releaseLock();\n    this._reader = null;\n    setTimeout(() => this._readLoop(id), 10);\n  }\n\n  async stopReadLoop() {\n    this._rl = false;\n    if (this._reader) {\n      this._reader.cancel();\n      await asyncTimeout(100);\n      await this.stopReadLoop();\n    }\n  }\n\n  async requestDevice() {\n    const device = await serial.requestPort({ classCode: 2 });\n    this.setCurrentDevice(device);\n    // if (!device.id) device.id = uuid4();\n    // if (await this.getDeviceName(device.id)) {\n    //   console.log(this.getDeviceName(device.id));\n    //   this.setCurrentDevice(device.id);\n    // } else {\n    //   this.emit('deviceNamePrompt', device.id);\n    // }\n  }\n\n  async isDevice(value) {\n    return !!(await this._getDevice(value));\n  }\n\n  async setCurrentDevice(value) {\n    if (!(await this.isDevice(value))) return;\n    if (this.connected) this.disconnect();\n    this._currentDevice = await this._getDevice(value);\n    Vue.set(this, 'currentDevice', value);\n    this.emit('currentDevice', value);\n    try {\n      await this.connect();\n    } catch (err) {\n      if (err.message === 'Access denied.') {\n        this.emit('errorPrompt', 'access_denied');\n      }\n      // eslint-disable-next-line no-console\n      console.error([err]);\n    }\n  }\n\n  async writeBuff(buff) {\n    const writer = this._currentDevice.writable.getWriter();\n    // console.log(buff);\n    // const encoder = new TextEncoder();\n    // const encoded = encoder.encode(buff.toString('utf8'), { stream: true });\n    // await Promise.all(encoded.map(async (chunk) => {\n    //   await writer.ready;\n    //   await writer.write(chunk);\n    // }));\n    // eslint-disable-next-line no-console\n    // console.log('write', Buffer.from(buff).toString('hex'));\n    // await writer.write(Buffer.from(buff).toString('hex') === '1b0100010e0114' ? Buffer.from('01', 'hex') : buff);\n    await writer.write(buff);\n    await writer.releaseLock();\n  }\n\n  async write(message) {\n    if (this.mute) return;\n    await this.writeBuff(Buffer.from(message, this.encoding));\n  }\n\n  async connect() {\n    if (!this._currentDevice) {\n      // console.log('skipping connect');\n      return;\n    }\n    if (this._currentDevice.readable) {\n      try {\n        await this.disconnect();\n        // eslint-disable-next-line no-console\n      } catch (err) { console.error(err); }\n    }\n    // console.log(await this._currentDevice.getInfo());\n    await this._currentDevice.open({\n      baudrate: this.baud,\n      baudRate: this.baud,\n    });\n    // console.log(1, this._currentDevice);\n    // console.log(1, this._currentDevice.getSignals());\n    this.connected = true;\n    this.emit('connected', this.currentDevice);\n    // const self = this;\n    // this._reader = new WritableStream({\n    //   start(controller) {\n    //     self._controller = controller;\n    //   },\n    //   write(chunk) {\n    //     // console.log('up', Buffer.from(chunk).toString(this.encoding));\n    //     if (!self.mute) self.emit('message', Buffer.from(chunk).toString(self.encoding));\n    //     self.emit('data', Buffer.from(chunk));\n    //   },\n    //   abort(err) {\n    //     console.log('Sink error:', err);\n    //   },\n    // });\n    // this._readableStreamClosed = this._currentDevice.readable.pipeTo(this._reader, { preventClose: true });\n    this._rl = Math.random();\n    this._readLoop(this._rl);\n  }\n\n  async disconnect() {\n    if (!this._currentDevice) return;\n    if (this._rl) await this.stopReadLoop();\n    await asyncTimeout(100);\n    await this._currentDevice.close();\n    await asyncTimeout(100);\n    // if (this._reader) {\n    //   this._controller.error('FooBar');\n    //   await this._readableStreamClosed.catch(Math.random);\n    // }\n    this.connected = false;\n    this.emit('disconnect', this.currentDevice);\n    // eslint-disable-next-line no-console\n    console.log('disconnected');\n  }\n\n  async setDeviceName(value, name) {\n    if (!(await this.isDevice(value))) return;\n    this.devices.push({ value, name });\n    localStorage.portNames = JSON.stringify(this.devices);\n    this.setCurrentDevice(value);\n  }\n\n  setSignals(signals) {\n    if (!this._currentDevice) throw new Error('Cannot write to closed port.');\n    const sigs = this._transSignal(signals);\n    return this._currentDevice.setSignals(sigs);\n  }\n}\n\nexport default NavSerial;\n"],"sourceRoot":""}