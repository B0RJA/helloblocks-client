{"version":3,"sources":["webpack:///./src/plugins/serial/base-serial.js","webpack:///./src/plugins/serial/navserial.js"],"names":["BaseSerial","requestRequired","mute","baud","Number","window","localStorage","currentBaudRate","lastBaud","encoding","devices","currentDevice","connected","implementation","Vue","$serial","this","prototype","Promise","all","map","device","isDevice","value","isDevices","filter","i","disconnect","console","error","connect","setBaud","val","sig","dtr","rts","signals","message","buff","name","push","find","d","EventEmitter","navigator","serial","asyncTimeout","ms","resolve","setTimeout","log","NavSerial","JSON","parse","portNames","_currentDevice","_rl","_reader","handlesSelect","id","readable","getReader","read","done","releaseLock","emit","Buffer","from","toString","_readLoop","stopReadLoop","requestPort","classCode","setCurrentDevice","_getDevice","set","writer","writable","getWriter","write","writeBuff","open","baudrate","Math","random","close","stringify","Error","setSignals","_transSignal"],"mappings":"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","file":"js/serial-nav-app.72e6770d.js","sourcesContent":["/* eslint-disable no-unused-vars */\n/* eslint-disable class-methods-use-this */\nimport EventEmitter from 'events';\n\n/*\nInterface should emit the following:\nthis.emit('data', buffer)\nthis.emit('message', string) // should be a string version of buffer\n// message should not be emitted whilst this.mute === true\nthis.emit('connected', value)\nthis.emit('disconnected', value)\nthis.emit('deviceNamePrompt', value) // prompts the user to input a readable device name\n*/\nclass BaseSerial extends EventEmitter {\n  constructor() {\n    super();\n    this.requestRequired = false;\n    this.mute = false;\n    this.baud = Number(window.localStorage.currentBaudRate) || 115200;\n    this.lastBaud = 115200;\n    this.encoding = 'ascii';\n    this.devices = [];\n    this.currentDevice = null;\n    this.connected = false;\n    this.implementation = 'basic';\n  }\n\n  install(Vue) {\n    // eslint-disable-next-line no-param-reassign\n    Vue.$serial = this;\n    // eslint-disable-next-line no-param-reassign\n    Vue.prototype.$serial = this;\n  }\n\n  async requestDevice() { return {}; }\n\n  async listDevices() {\n    const isDevices = await Promise.all(this.devices.map((device) => this.isDevice(device.value)));\n    return this.devices.filter((device, i) => isDevices[i]);\n  }\n\n  async isDevice(value) { return true; }\n\n  async setCurrentDevice(value) { this.currentDevice = value; }\n\n  async setBaud(baud) {\n    try {\n      await this.disconnect();\n      // eslint-disable-next-line no-console\n    } catch (err) { console.error(err); }\n    this.lastBaud = this.baud;\n    this.baud = baud;\n    await this.connect();\n    window.localStorage.currentBaudRate = baud;\n    return baud;\n  }\n\n  async resetBaud() {\n    this.setBaud(this.lastBaud);\n  }\n\n  async setMute(val) { this.mute = val; }\n\n  _transSignal(sig) {\n    if (sig === 'on' || sig === true) return { dtr: true, rts: true };\n    if (sig === 'off' || sig === false) return { dtr: false, rts: false };\n    return sig;\n  }\n\n  async setSignals(signals) { return signals; }\n\n  async write(message) { return message; }\n\n  async writeBuff(buff) { return buff; }\n\n  async connect() { this.connected = true; }\n\n  async disconnect() { this.connected = false; }\n\n  async setDeviceName(value, name) {\n    if (await this.isDevice(value)) this.devices.push({ value, name });\n  }\n\n  async getDeviceName(value) {\n    return (this.devices.find((d) => d.value === value) || { name: '' }).name;\n  }\n}\n\nexport default BaseSerial;\n","import Vue from 'vue';\n// import { v4 as uuid4 } from 'uuid';\nimport BaseSerial from './base-serial';\n\nconst { serial } = navigator;\nconst asyncTimeout = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\n\n// eslint-disable-next-line no-console\nconsole.log('using navserial');\nclass NavSerial extends BaseSerial {\n  constructor() {\n    super();\n    this.requestRequired = true;\n    this.devices = JSON.parse(localStorage.portNames || '[]');\n    this._currentDevice = null;\n    this._rl = false;\n    this._reader = null;\n    this.implementation = 'navserial';\n    this.handlesSelect = true;\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  async _getDevice(value) {\n    // const devices = await serial.getPorts();\n    // console.log(devices);\n    // return devices.find((d) => d.id === value) || null;\n    return value;\n  }\n\n  async _readLoop(id) {\n    if (!this._rl || id !== this._rl) return;\n    if (!this._currentDevice || !this._currentDevice.readable) {\n      this._rl = false;\n      return;\n    }\n    try {\n      this._reader = this._currentDevice.readable.getReader();\n      // eslint-disable-next-line no-constant-condition\n      while (id === this._rl) {\n        // eslint-disable-next-line no-await-in-loop\n        const { value, done } = await this._reader.read();\n        if (done) {\n          this._reader.releaseLock();\n          break;\n        }\n        this.emit('data', Buffer.from(value));\n        if (!this.mute) this.emit('message', Buffer.from(value).toString(this.encoding));\n      }\n    } catch (e) {\n      this.emit('message', `<ERROR: ${e.message}>`);\n    }\n    if (this._reader) this._reader.releaseLock();\n    this._reader = null;\n    setTimeout(() => this._readLoop(id), 10);\n  }\n\n  async stopReadLoop() {\n    this._rl = false;\n    if (this._reader) {\n      await asyncTimeout(100);\n      await this.stopReadLoop();\n    }\n  }\n\n  async requestDevice() {\n    const device = await serial.requestPort({ classCode: 2 });\n    this.setCurrentDevice(device);\n    // if (!device.id) device.id = uuid4();\n    // if (await this.getDeviceName(device.id)) {\n    //   console.log(this.getDeviceName(device.id));\n    //   this.setCurrentDevice(device.id);\n    // } else {\n    //   this.emit('deviceNamePrompt', device.id);\n    // }\n  }\n\n  async isDevice(value) {\n    return !!(await this._getDevice(value));\n  }\n\n  async setCurrentDevice(value) {\n    if (!(await this.isDevice(value))) return;\n    if (this.connected) this.disconnect();\n    this._currentDevice = await this._getDevice(value);\n    Vue.set(this, 'currentDevice', value);\n    this.emit('currentDevice', value);\n    try {\n      await this.connect();\n    } catch (err) {\n      if (err.message === 'Access denied.') {\n        this.emit('errorPrompt', 'access_denied');\n      }\n      // eslint-disable-next-line no-console\n      console.error([err]);\n    }\n  }\n\n  async writeBuff(buff) {\n    const writer = this._currentDevice.writable.getWriter();\n    // console.log(buff);\n    // const encoder = new TextEncoder();\n    // const encoded = encoder.encode(buff.toString('utf8'), { stream: true });\n    // await Promise.all(encoded.map(async (chunk) => {\n    //   await writer.ready;\n    //   await writer.write(chunk);\n    // }));\n    await writer.write(buff);\n    await writer.releaseLock();\n  }\n\n  async write(message) {\n    if (this.mute) return;\n    await this.writeBuff(Buffer.from(message, this.encoding));\n  }\n\n  async connect() {\n    if (!this._currentDevice) {\n      // console.log('skipping connect');\n      return;\n    }\n    if (this._currentDevice.readable) {\n      try {\n        await this.disconnect();\n        // eslint-disable-next-line no-console\n      } catch (err) { console.error(err); }\n    }\n    // console.log(await this._currentDevice.getInfo());\n    await this._currentDevice.open({\n      baudrate: this.baud,\n    });\n    // console.log(1, this._currentDevice);\n    // console.log(1, this._currentDevice.getSignals());\n    this.connected = true;\n    this.emit('connected', this.currentDevice);\n    // const self = this;\n    // this._reader = new WritableStream({\n    //   start(controller) {\n    //     self._controller = controller;\n    //   },\n    //   write(chunk) {\n    //     // console.log('up', Buffer.from(chunk).toString(this.encoding));\n    //     if (!self.mute) self.emit('message', Buffer.from(chunk).toString(self.encoding));\n    //     self.emit('data', Buffer.from(chunk));\n    //   },\n    //   abort(err) {\n    //     console.log('Sink error:', err);\n    //   },\n    // });\n    // this._readableStreamClosed = this._currentDevice.readable.pipeTo(this._reader, { preventClose: true });\n    this._rl = Math.random();\n    this._readLoop(this._rl);\n  }\n\n  async disconnect() {\n    if (!this._currentDevice) return;\n    if (this._rl) await this.stopReadLoop();\n    await asyncTimeout(100);\n    await this._currentDevice.close();\n    await asyncTimeout(100);\n    // if (this._reader) {\n    //   this._controller.error('FooBar');\n    //   await this._readableStreamClosed.catch(Math.random);\n    // }\n    this.connected = false;\n    this.emit('disconnect', this.currentDevice);\n    // eslint-disable-next-line no-console\n    console.log('disconnected');\n  }\n\n  async setDeviceName(value, name) {\n    if (!(await this.isDevice(value))) return;\n    this.devices.push({ value, name });\n    localStorage.portNames = JSON.stringify(this.devices);\n    this.setCurrentDevice(value);\n  }\n\n  setSignals(signals) {\n    if (!this._currentDevice) throw new Error('Cannot write to closed port.');\n    return this._currentDevice.setSignals(this._transSignal(signals));\n  }\n}\n\nexport default NavSerial;\n"],"sourceRoot":""}